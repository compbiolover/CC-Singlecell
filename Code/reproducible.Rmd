---
title: "reproducible"
author: "Andrew Willems and Tian Hong"
date: "3/29/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reproducible document for all CC Singlecell analysis

This document encompasses all steps, code, and data used for the CC Singlecell paper


## Step One: Loading needed packages
```{r message=FALSE, echo=FALSE}
#Loading needed packages
library(data.table)
library(ggplot2)
library(phateR)
library(SummarizedExperiment)
library(survival)
library(survminer)
library(svglite)
library(TCGAbiolinks)
library(tidyverse)
library(viridis)
```

## Step Two: Loading in the functions we need from their separate files
```{r}
#Loading the needed functions from their respective files
source("Code/cell_dataset_builder.R")
source("Code/cox_model.R")
source("Code/mad_calculator.R")
source("Code/magic_denoiser.R")
source("Code/mirna_calculator_original.R")
source("Code/model_optimizer.R")
source("Code/switchde_calculator.R")
```

## Step Three: Loading in the single-cell data
```{r}
#Loading single-cell data that is used for both colon and rectal cancer data sets
cc_tumor_fpkm <- read.csv("Single-cell-data/FPKM/GSE81861_CRC_tumor_all_cells_FPKM.csv")
head(cc_tumor_fpkm)
```

## Step Four: Doing some pre-processing to clean up the gene names
```{r}
#Processing the single-cell data to clean up the gene names
rownames(cc_tumor_fpkm) <- cc_tumor_fpkm$X
current_colname_split <- strsplit(colnames(t(cc_tumor_fpkm)), "_")
finished_gene_list <- c()
for (x in seq(1:length(current_colname_split))){
  finished_gene_list <- c(finished_gene_list, current_colname_split[[x]][2])
}

cc_tumor_fpkm <- t(cc_tumor_fpkm)
colnames(cc_tumor_fpkm) <- finished_gene_list
cc_tumor_fpkm <- t(cc_tumor_fpkm)
cc_tumor_fpkm <- subset(cc_tumor_fpkm,
                        select=c(RHC3546__Tcell__.C6E879:RHC6041__Macrophage__.FFFF55))
cc_tumor_fpkm <- apply(cc_tumor_fpkm, c(1,2), as.numeric)

head(as.data.frame(cc_tumor_fpkm))
```

## Step Five: Pre-processing the scRNA-seq data before sending it to MAGIC. We are only keeping genes expressed in at least 10 cells
```{r}
keep_rows <- rowSums(cc_tumor_fpkm > 0) > 10
cc_tumor_fpkm <- cc_tumor_fpkm[keep_rows,]
head(as.data.frame(cc_tumor_fpkm))
```

```{r}
#Looking at the distribution of library sizes
library_size_plot_1 <- ggplot() +
  geom_histogram(aes(x=colSums(cc_tumor_fpkm)), bins=100) +
  geom_vline(xintercept = 1000, color='red') +
  theme(panel.background = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))+
  xlab("Library Size Distribution")+
  ylab("Count") + ggtitle("Single-cell Library Size")+
  scale_y_continuous(limits=c(0, 18), expand = c(0, 0))

library_size_plot_1

ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/single_cell_library_histogram_pre_process_step_1.svg",
      device = "svg", units = "cm", dpi = 300, width = 20, height = 20,
      plot = library_size_plot_1)

```

## Step Six: We normalize the library size with the 'library.size.normalize' command from the phateR package. This command performs L1 normalization on input data such that the sum of expression values for each cell sums to 1, then returns normalized matrix to the metric space using median UMI count per cell effectively scaling all cells as if they were sampled evenly. We then take the square-root of the dataset to transform the data, but avoid the instabilities and pseudocounts needed when taking the log of the dataset. 
```{r}
#Normalizing the library size
cc_tumor_fpkm <- library.size.normalize(cc_tumor_fpkm)
head(as.data.frame(cc_tumor_fpkm))
cc_tumor_fpkm <- sqrt(cc_tumor_fpkm)
head(as.data.frame(cc_tumor_fpkm))

library_size_plot_2 <- ggplot() +
  geom_histogram(aes(x=colSums(cc_tumor_fpkm)), bins=100) +
  geom_vline(xintercept = 1000, color='red') +
  theme(panel.background = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))+
  xlab("Library Size Distribution")+
  ylab("Count") + ggtitle("Single-cell Library Size Normalized")+
  scale_y_continuous(limits=c(0, 18), expand = c(0, 0))

library_size_plot_2

ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/single_cell_library_histogram_pre_process_step_2.svg",
      device = "svg", units = "cm", dpi = 300, width = 20, height = 20,
      plot = library_size_plot_2)
```


```{r}
#Denoising the single-cell data and saving the output
cc_tumor_fpkm <- magic_denoiser(sc.data = cc_tumor_fpkm,
                                magic.seed = 123, magic.solver = 'approximate')

saveRDS(cc_tumor_fpkm$denoised_sc_dataframe,
        file = "Outputs/denoised-colon-and-rectal-single-cell-data.rds")

head(as.data.frame(cc_tumor_fpkm$denoised_sc_dataframe))

saveRDS(cc_tumor_fpkm$cds_gene_names,
        file = "Outputs/denoised-colon-and-rectal-single-cell-data-gene-names.rds")

head(cc_tumor_fpkm$cds_gene_names)
```

## Step Seven: Now generating the VIM based pseudotime progression via Monocle3. Based on the expresson of VIM we select the root that has the lowest expression of VIM as the starting point of our pseudotime (i.e., where our pseudotime is zero). IF your dataset has a different point with zero expression modify the line 'my.root'. 
```{r echo=FALSE}
#Generating the VIM based pseudotime progression with Monocle3
#Based on the expression of the VIM graph we select the bottom-rightmost point
#as the root of our pseudotime as this matches the gradient of VIM expression
#level
cds_output <- cell_dataset_builder(vim.genes = c("VIM", "VIMP"),
                                   cell.data = cc_tumor_fpkm$denoised_sc_dataframe,
                                   cell.meta = cc_tumor_fpkm$cds_gene_names,
                                   my.root = "Y_19",
                                   my.cds.filename = "Outputs/cds_ouput.rds",
                                   my.monocle.graph = "Outputs/vim_pseudotime.svg",
                                   my.monocle.graph.genes = "Outputs/vim_genes.svg",
                                   my.pt.data.filename = "Outputs/vim_pseudotime_data.csv")

cds_output$`PT Graph`
cds_output$`Cell Progression Graph`
```

## Step Eight: We are now making the ranked list of genes from the single-cell data for our median absolute deviation (MAD) metric. 
```{r}
#MAD metric for colon and rectal cancer
mad.genes <- mad_calculator(cc_tumor_fpkm$denoised_sc_dataframe)
saveRDS(mad.genes,
        file = "Outputs/mad_colon_and_rectal_cancer.rds")

head(mad.genes)
```

## Step Nine: We are now making the ranked list of genes from the single-cell data for our switchde (SDE) metric. 
```{r}
#Switchde metric for colon and rectal cancer----
sde.genes <- switchde_calculator(cc_tumor_fpkm$denoised_sc_dataframe,
                                 pseudo.time = cds_output$Pseudotime)

head(sde.genes)

saveRDS(sde.genes,
        file = "Outputs/sde_colon_and_rectal_cancer.rds")

```

## Step Ten: Downloading the COAD bulk dataset from TCGA. We are using the FPKM (now called STAR - Counts) dataset.
```{r}
#Now getting our Colon cancer bulk data set
#TCGA-COAD
coad_query <- GDCquery(project       = "TCGA-COAD",
                       data.category = "Transcriptome Profiling",
                       data.type     = "Gene Expression Quantification",
                       workflow.type = "STAR - Counts")

#Downloading the files
GDCdownload(query           = coad_query,
            method          = "api",
            files.per.chunk = 5,
            directory       = "Outputs/Bulk-data/")


#Making the SummarizedExperiment object
coad_data_se <- GDCprepare(coad_query, summarizedExperiment = TRUE,
                           directory = "Outputs/Bulk-data/")
coad_data_df <- as.data.frame(colData(coad_data_se))
coad_data_df$vital_status <- factor(coad_data_df$vital_status,
                                    levels = c("Alive", "Dead"),
                                    labels = c(0,1))
coad_data_df$vital_status <- as.numeric(as.character(coad_data_df$vital_status))


bulk_rna_df <- coad_data_se@assays@data@listData[["STAR - Counts"]]
colnames(bulk_rna_df) <- coad_data_se@colData@rownames
rownames(bulk_rna_df) <- coad_data_se@rowRanges@elementMetadata@listData[["external_gene_name"]]
bulk_rna_df <- t(bulk_rna_df)
bulk_rna_df <- as.data.frame(bulk_rna_df)
bulk_rownames <- rownames(bulk_rna_df)
bulk_rna_df$barcode <- bulk_rownames

bulk_rna_df_unique <- subset(bulk_rna_df,
                             select = unique(colnames(bulk_rna_df)))
coad_data_df_unique <- subset(coad_data_df,
                              select = unique(colnames(coad_data_df)))
merged_df <- merge(bulk_rna_df_unique, coad_data_df_unique, by = 'barcode')
rownames(merged_df) <- merged_df$barcode
merged_df <- merged_df[,2:length(colnames(merged_df))]



merged_df$days_to_last_follow_up <- ifelse(merged_df$vital_status==1,
                                           merged_df$days_to_death,
                                           merged_df$days_to_last_follow_up)

merged_df <- filter(merged_df, days_to_last_follow_up != "NA")


cox_time <- merged_df$days_to_last_follow_up
cox_event <- merged_df$vital_status
cox_tumor <- merged_df$ajcc_pathologic_stage
cox_tumor_n <- merged_df$ajcc_pathologic_n
cox_tumor_m <- merged_df$ajcc_pathologic_m
cox_gender <- merged_df$gender
cox_eth <- merged_df$ethnicity
cox_race <- merged_df$race
cox_type <- merged_df$definition
cox_df <- subset(merged_df, select=c(TSPAN6:AC007389.5))
cox_df$days.to.last.follow.up <- cox_time
cox_df$vital.status <- cox_event
cox_df$tumor.stage <- cox_tumor
cox_df$ajcc.m <- cox_tumor_m
cox_df$ajcc.n <- cox_tumor_n
cox_df$race <- cox_race
cox_df$ethnicity <- cox_eth
cox_df$gender <- cox_gender
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern="A", replacement="")
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern="B", replacement="")
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern="C", replacement="")
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage IV", replacement = 4)
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage III", replacement = 3)
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage II", replacement = 2)
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage I", replacement = 1)
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="a", replacement="")
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="b", replacement="")
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="c", replacement="")
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="N0", replacement=0)
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="N1", replacement=1)
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="N2", replacement=2)
cox_df$sample.type <- cox_type
cox_df <- filter(cox_df, !tumor.stage=="not reported")
cox_df <- cox_df[complete.cases(cox_df[, "ajcc.m"]), ]
cox_df$days.to.last.follow.up <- ifelse(cox_df$days.to.last.follow.up < 1, 1,
                                        cox_df$days.to.last.follow.up)

saveRDS(cox_df, "Outputs/coad_df.rds")

cox_df <- readRDS("Outputs/coad_df_finished.rds")

head(cox_df)
```

## Step Eleven: Getting ideal gene number for MAD metric on TCGA-COAD
```{r}
#Getting ideal gene number for MAD metric on TCGA-COAD
gene_sizes <- seq(100, 3000, 50)
mad_cindices <- rep(0, length(gene_sizes))

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = mad.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Outputs/mad_coad_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mad_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mad_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mad_cindices_coad_df <- as.data.frame(cbind(gene_sizes, mad_cindices))
mad_cindices_coad_df$method <- rep("MAD", nrow(mad_cindices_coad_df))
colnames(mad_cindices_coad_df)[2] <- "c_index"
write.csv(mad_cindices_coad_df,
          "Outputs/mad_cindices_coad_across_gene_size.csv")

```

## Step Twelve: Getting ideal gene number for SDE metric on TCGA-COAD
```{r}
#Getting ideal gene number for SDE metric on TCGA-COAD
gene_sizes <- seq(100, 3000, 50)
sde_cindices <- rep(0, length(gene_sizes))

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = sde.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Outputs/sde_coad_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the sde_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  sde_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
sde_cindices_coad_df <- as.data.frame(cbind(gene_sizes, sde_cindices))
sde_cindices_coad_df$method <- rep("SDE", nrow(sde_cindices_coad_df))
colnames(sde_cindices_coad_df)[2] <- "c_index"
write.csv(sde_cindices_coad_df,
          "Outputs/sde_cindices_coad_across_gene_size.csv")
```

## Step Thirteen: Getting the ideal gene number for the miRNA metric on TCGA-COAD
```{r}
#Getting ideal gene number for miRNA metric on TCGA-COAD----
#For this metric we don't know which combination of miRNA and miRNA targets
#will yield the best result in advance so we are trying 3 different miRNA-
#miRNA target combinations that encompass specific areas of our grid search.
#They are low miRNA number and low miRNA target number, medium miRNA number and
#medium miRNA target number, and high miRNA number and high miRNA target number.
#Once the ideal miRNA-miRNA target pair is known from the grid search we will
#also include a gene size search for it here
gene_sizes <- seq(100, 3000, 50)
mirna_high_cindices <- rep(0, length(gene_sizes))
mirna_medium_cindices <- rep(0, length(gene_sizes))
mirna_low_cindices <- rep(0, length(gene_sizes))

#Loading the high miRNA-miRNA target file
load("Data/800_1010_targets.RData", verbose = TRUE)

high.mirna.genes <- mirna.ranking

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = high.mirna.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Data/high_mirna_coad_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mirna_high_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mirna_high_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mirna_high_cindices_coad_df <- as.data.frame(cbind(gene_sizes,
                                                   mirna_high_cindices))

colnames(mirna_high_cindices_coad_df) [2] <- "c_index"
mirna_high_cindices_coad_df$mirna_type <- rep("high",
                                              nrow(mirna_high_cindices_coad_df))

write.csv(mirna_high_cindices_coad_df,
          "Data/Reproducible-results/Data/mirna_high_cindices_coad_across_gene_size.csv")


#Medium miRNA-miRNA target number
#Loading the medium miRNA-miRNA target file
load("Data/Reproducible-results/Data/400_510_targets.RData", verbose = TRUE)

medium.mirna.genes <- mirna.ranking

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = medium.mirna.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Data/medium_mirna_coad_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mirna_medium_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mirna_medium_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mirna_medium_cindices_coad_df <- as.data.frame(cbind(gene_sizes,
                                                   mirna_medium_cindices))

colnames(mirna_medium_cindices_coad_df) [2] <- "c_index"
mirna_medium_cindices_coad_df$mirna_type <- rep("medium",
                                                nrow(mirna_medium_cindices_coad_df))

write.csv(mirna_medium_cindices_coad_df,
          "Data/Reproducible-results/Data/mirna_medium_cindices_coad_across_gene_size.csv")

#low miRNA-miRNA target number
#Loading the low miRNA-miRNA target file
load("Data/Reproducible-results/Data/100_10_targets.RData", verbose = TRUE)

low.mirna.genes <- mirna.ranking

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = low.mirna.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Data/low_mirna_coad_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mirna_medium_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mirna_low_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mirna_low_cindices_coad_df <- as.data.frame(cbind(gene_sizes,
                                                     mirna_low_cindices))

colnames(mirna_low_cindices_coad_df)[2] <- "c_index"
mirna_low_cindices_coad_df$mirna_type <- rep("low",
                                             nrow(mirna_low_cindices_coad_df))

write.csv(mirna_low_cindices_coad_df,
          "Data/Reproducible-results/Data/mirna_low_cindices_coad_across_gene_size.csv")


#Binding all the rows of the 3 different miRNA data frames together into 1 big
#data frame
all_mirna_metrics_coad_df <- bind_rows(mirna_low_cindices_coad_df,
                                            mirna_medium_cindices_coad_df,
                                            mirna_high_cindices_coad_df)

all_mirna_metrics_coad_df <- all_mirna_metrics_coad_df[,2:4]

#Reordering the labels to make them look nicer on the plot
all_mirna_metrics_coad_df$mirna_type <- factor(all_mirna_metrics_coad_df$mirna_type,
                                               levels = c("low", "medium", "high"))

#Basic miRNA-miRNA target plot
all_mirna_metrics_coad_plot <- ggplot(data = all_mirna_metrics_coad_df,
                                      aes(x=gene_sizes, y=c_index, color=mirna_type))

#Making the plot much nicer
all_mirna_metrics_coad_plot_finished <-all_mirna_metrics_coad_plot +
  geom_line(size=2.5) + geom_point(size=3.0)+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 40, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 40, face = "bold"),
        legend.title = element_text(size = 30, face = "bold"),
        legend.position = "bottom", 
        legend.text = element_text(size = 35, face = "plain"),
        axis.text=element_text(size=25, face="bold"))+
  xlab("Gene Size")+ ylab("Mean Concordance Index")+
  ggtitle("miRNA-miRNA Target Number")+ 
  labs(color="miRNA-miRNA Target Number")+
  scale_color_viridis_d()


#Saving the finished graph in .svg format
ggsave(filename = "Data/Reproducible-results/Figures/mirna_mirna_target_num_across_gene_size.svg",
       plot     = print(all_mirna_metrics_coad_plot_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")
```

## Step Fourteen: Getting the ideal gene size for all individual metrics
```{r}
#Optimal gene size for MAD, SDE, and miRNA high metric----
#First bind the data frames together
methods_optimal_gene_coad_df <- bind_rows(mad_cindices_coad_df, 
                                        sde_cindices_coad_df,
                                        mirna_high_cindices_coad_df)

methods_optimal_gene_coad_df <- methods_optimal_gene_coad_df[,1:3]

methods_optimal_gene_coad_df$method[119:177] <- rep("miRNA", 58)

#Saving the data frame
write.csv(methods_optimal_gene_coad_df,
          "Data/Reproducible-results/Data/individual_optimal_gene_point_coad_data.csv")

#Basic miRNA-miRNA target plot
methods_optimal_gene_coad_plot <- ggplot(data = methods_optimal_gene_coad_df,
                                      aes(x=gene_sizes, y=c_index, color=method))

#Making the plot much nicer
methods_optimal_gene_coad_plot_finished <-methods_optimal_gene_coad_plot +
  geom_line(size=2.5) + geom_point(size=3.0)+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 40, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 40, face = "bold"),
        legend.title = element_text(size = 30, face = "bold"),
        legend.position = "bottom", 
        legend.text = element_text(size = 35, face = "plain"),
        axis.text=element_text(size=25, face="bold"))+
  xlab("Gene Size")+ ylab("Mean Concordance Index")+
  ggtitle("Optimal Gene Number")+ 
  labs(color="Method")+
  scale_color_manual(values = c("#21908CFF","#FDE725FF", "#440154FF"))


#Saving the finished graph in .svg format
ggsave(filename = "Data/Reproducible-results/Figures/individual_metrics_optimal_gene_size_coad.svg",
       plot     = print(methods_optimal_gene_coad_plot_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")
```

## Step Fifteen: Getting the bulk rectal cancer dataset
```{r}
#Now doing all of these steps for the rectal cancer data set from TCGA-READ
#Now getting our rectal cancer bulk data set
#TCGA-READ
read_query <- GDCquery(project       = "TCGA-READ",
                       data.category = "Transcriptome Profiling",
                       data.type     = "Gene Expression Quantification",
                       workflow.type = "HTSeq - FPKM")

#Downloading the files
GDCdownload(query           = read_query,
            method          = "api",
            files.per.chunk = 10,
            directory       = "Data/Reproducible-results/Data/Bulk-data/")


#Making the SummarizedExperiment object
read_data_se <- GDCprepare(read_query, summarizedExperiment = TRUE,
                           directory = "Data/Reproducible-results/Data/Bulk-data/")
read_data_df <- as.data.frame(colData(read_data_se))
read_data_df$vital_status <- factor(read_data_df$vital_status,
                                    levels = c("Alive", "Dead"),
                                    labels = c(0,1))
read_data_df$vital_status <- as.numeric(as.character(read_data_df$vital_status))


bulk_rna_df <- read_data_se@assays@data@listData[["HTSeq - FPKM"]]
colnames(bulk_rna_df) <- read_data_se@colData@rownames
rownames(bulk_rna_df) <- read_data_se@rowRanges@elementMetadata@listData[["external_gene_name"]]
bulk_rna_df <- t(bulk_rna_df)
bulk_rna_df <- as.data.frame(bulk_rna_df)
bulk_rownames <- rownames(bulk_rna_df)
bulk_rna_df$barcode <- bulk_rownames

bulk_rna_df_unique <- subset(bulk_rna_df,
                             select = unique(colnames(bulk_rna_df)))
read_data_df_unique <- subset(read_data_df,
                              select = unique(colnames(read_data_df)))
merged_df <- merge(bulk_rna_df_unique, read_data_df_unique, by = 'barcode')
rownames(merged_df) <- merged_df$barcode
merged_df <- merged_df[,2:length(colnames(merged_df))]



merged_df$days_to_last_follow_up <- ifelse(merged_df$vital_status==1,
                                           merged_df$days_to_death,
                                           merged_df$days_to_last_follow_up)

merged_df <- filter(merged_df, days_to_last_follow_up != "NA")


cox_time <- merged_df$days_to_last_follow_up
cox_event <- merged_df$vital_status
cox_tumor <- merged_df$ajcc_pathologic_stage
cox_tumor_n <- merged_df$ajcc_pathologic_n
cox_tumor_m <- merged_df$ajcc_pathologic_m
cox_gender <- merged_df$gender
cox_eth <- merged_df$ethnicity
cox_race <- merged_df$race
cox_type <- merged_df$definition
cox_df <- subset(merged_df, select=c(TSPAN6:AC007389.5))
cox_df$days.to.last.follow.up <- cox_time
cox_df$vital.status <- cox_event
cox_df$tumor.stage <- cox_tumor
cox_df$ajcc.m <- cox_tumor_m
cox_df$ajcc.n <- cox_tumor_n
cox_df$race <- cox_race
cox_df$ethnicity <- cox_eth
cox_df$gender <- cox_gender
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern="A", replacement="")
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern="B", replacement="")
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern="C", replacement="")
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage IV", replacement = 4)
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage III", replacement = 3)
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage II", replacement = 2)
cox_df$tumor.stage <- gsub(cox_df$tumor.stage, pattern = "Stage I", replacement = 1)
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="a", replacement="")
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="b", replacement="")
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="c", replacement="")
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="N0", replacement=0)
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="N1", replacement=1)
cox_df$ajcc.n <- gsub(cox_df$ajcc.n, pattern="N2", replacement=2)
cox_df$sample.type <- cox_type
cox_df <- filter(cox_df, !tumor.stage=="not reported")
cox_df <- cox_df[complete.cases(cox_df[, "ajcc.m"]), ]
cox_df$days.to.last.follow.up <- ifelse(cox_df$days.to.last.follow.up < 1, 1,
                                        cox_df$days.to.last.follow.up)
saveRDS(cox_df, "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/read_df_finished.rds")

cox_df <- readRDS("Data/Reproducible-results/Rmarkdown/read_df_finished.rds")
```

## Step Sixteen: Now doing the same analysis that we did in steps 11-14 but for the READ dataset
```{r}
#Getting ideal gene number for MAD metric on TCGA-READ
gene_sizes <- seq(100, 3000, 50)
mad_cindices <- rep(0, length(gene_sizes))

#Loading in the MAD and SDE files if they aren't already loaded into the 
#environment from earlier
mad.genes <-readRDS("Data/Reproducible-results/Data/mad_colon_and_rectal_cancer.rds")
sde.genes <- readRDS("Data/Reproducible-results/Data/sde_colon_and_rectal_cancer.rds")

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = mad.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/mad_read_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mad_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mad_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mad_cindices_read_df <- as.data.frame(cbind(gene_sizes, mad_cindices))
mad_cindices_read_df$method <- rep("MAD", nrow(mad_cindices_read_df))
colnames(mad_cindices_read_df)[2] <- "c_index"
write.csv(mad_cindices_read_df,
          "Data/Reproducible-results/Rmarkdown/mad_cindices_read_across_gene_size.csv")
```

```{r}
#Getting ideal gene number for SDE metric on TCGA-READ
gene_sizes <- seq(100, 3000, 50)
sde_cindices <- rep(0, length(gene_sizes))

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = sde.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/sde_read_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the sde_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  sde_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
sde_cindices_read_df <- as.data.frame(cbind(gene_sizes, sde_cindices))
sde_cindices_read_df$method <- rep("SDE", nrow(sde_cindices_read_df))
colnames(sde_cindices_read_df)[2] <- "c_index"
write.csv(sde_cindices_read_df,
          "Data/Reproducible-results/Rmarkdown/sde_cindices_read_across_gene_size.csv")
```

```{r}
#Getting ideal gene number for miRNA metric on TCGA-READ
#For this metric we don't know which combination of miRNA and miRNA targets
#will yield the best result in advance so we are trying 3 different miRNA-
#miRNA target combinations that encompass specific areas of our grid search.
#They are low miRNA number and low miRNA target number, medium miRNA number and
#medium miRNA target number, and high miRNA number and high miRNA target number.
#Once the ideal miRNA-miRNA target pair is known from the grid search we will
#also include a gene size search for it here
gene_sizes <- seq(100, 3000, 50)
mirna_high_cindices <- rep(0, length(gene_sizes))
mirna_medium_cindices <- rep(0, length(gene_sizes))
mirna_low_cindices <- rep(0, length(gene_sizes))

#Loading the high miRNA-miRNA target file
load("Data/Reproducible-results/Data/800_1010_targets.RData", verbose = TRUE)
load("Data/Reproducible-results/Data/1000_110_targets.RData", verbose = TRUE)
load("Data/Reproducible-results/Data/1000_1010_targets.RData", verbose = TRUE)

high.mirna.genes <- mirna.ranking

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = high.mirna.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/high_mirna3_read_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mirna_high_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mirna_high_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mirna_high_cindices_read_df <- as.data.frame(cbind(gene_sizes,
                                                   mirna_high_cindices))

colnames(mirna_high_cindices_read_df) [2] <- "c_index"
mirna_high_cindices_read_df$mirna_type <- rep("high",
                                              nrow(mirna_high_cindices_read_df))

write.csv(mirna_high_cindices_read_df,
          "Data/Reproducible-results/Rmarkdown/mirna_high_cindices_read_across_gene_size3.csv")


#Medium miRNA-miRNA target number
#Loading the medium miRNA-miRNA target file
load("Data/Reproducible-results/Data/400_510_targets.RData", verbose = TRUE)

medium.mirna.genes <- mirna.ranking

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = medium.mirna.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/medium_mirna_read_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mirna_medium_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mirna_medium_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mirna_medium_cindices_read_df <- as.data.frame(cbind(gene_sizes,
                                                     mirna_medium_cindices))

colnames(mirna_medium_cindices_read_df) [2] <- "c_index"
mirna_medium_cindices_read_df$mirna_type <- rep("medium",
                                                nrow(mirna_medium_cindices_read_df))

write.csv(mirna_medium_cindices_read_df,
          "Data/Reproducible-results/Rmarkdown/mirna_medium_cindices_read_across_gene_size.csv")

#low miRNA-miRNA target number
#Loading the low miRNA-miRNA target file
load("Data/Reproducible-results/Data/100_10_targets.RData", verbose = TRUE)

low.mirna.genes <- mirna.ranking

for(gs in gene_sizes){
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = low.mirna.genes,
                                cox.df = cox_df,
                                gene.num = gs,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/low_mirna_read_coefs_",gs,"_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the mirna_medium_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  mirna_low_cindices[which(gene_sizes==gs)] <- top_cindex
  
}

#Binding the gene size and c-index vectors together to get the finished data
#frame
mirna_low_cindices_read_df <- as.data.frame(cbind(gene_sizes,
                                                  mirna_low_cindices))

colnames(mirna_low_cindices_read_df)[2] <- "c_index"
mirna_low_cindices_read_df$mirna_type <- rep("low",
                                             nrow(mirna_low_cindices_read_df))

write.csv(mirna_low_cindices_read_df,
          "Data/Reproducible-results/Rmarkdown/mirna_low_cindices_read_across_gene_size.csv")


#Binding all the rows of the 3 different miRNA data frames together into 1 big
#data frame
all_mirna_metrics_read_df <- bind_rows(mirna_low_cindices_read_df,
                                       mirna_medium_cindices_read_df,
                                       mirna_high_cindices_read_df)

all_mirna_metrics_read_df <- all_mirna_metrics_read_df[,2:4]

#Reordering the labels to make them look nicer on the plot
all_mirna_metrics_read_df$mirna_type <- factor(all_mirna_metrics_read_df$mirna_type,
                                               levels = c("low", "medium", "high"))

#Basic miRNA-miRNA target plot
all_mirna_metrics_read_plot <- ggplot(data = all_mirna_metrics_read_df,
                                      aes(x=gene_sizes, y=c_index, color=mirna_type))

#Making the plot much nicer
all_mirna_metrics_read_plot_finished <-all_mirna_metrics_read_plot +
  geom_line(size=2.5) + geom_point(size=3.0)+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 40, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 40, face = "bold"),
        legend.title = element_text(size = 30, face = "bold"),
        legend.position = "bottom", 
        legend.text = element_text(size = 35, face = "plain"),
        axis.text=element_text(size=25, face="bold"))+
  xlab("Gene Size")+ ylab("Mean Concordance Index")+
  ggtitle("miRNA-miRNA Target Number")+ 
  labs(color="miRNA-miRNA Target Number")+
  scale_color_viridis_d()


#Saving the finished graph in .svg format
ggsave(filename = "Data/Reproducible-results/Rmarkdown/mirna_mirna_target_num_across_gene_size_read.svg",
       plot     = print(all_mirna_metrics_read_plot_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")
```

```{r}
#Optimal gene size for MAD, SDE, and miRNA high metric----
#First bind the data frames together
methods_optimal_gene_read_df <- bind_rows(mad_cindices_read_df, 
                                          sde_cindices_read_df,
                                          mirna_high_cindices_read_df)

methods_optimal_gene_read_df <- methods_optimal_gene_read_df[,1:3]

methods_optimal_gene_read_df$method[119:177] <- rep("miRNA", 58)

#Saving the data frame
write.csv(methods_optimal_gene_read_df,
          "Data/Reproducible-results/Data/individual_optimal_gene_point_read_data.csv")

methods_optimal_gene_read_df <- methods_optimal_gene_read_df[,2:4]

#Basic miRNA-miRNA target plot
methods_optimal_gene_read_plot <- ggplot(data = methods_optimal_gene_read_df,
                                         aes(x=gene_sizes, y=c_index, color=method))

#Making the plot much nicer
methods_optimal_gene_read_plot_finished <-methods_optimal_gene_read_plot +
  geom_line(size=2.5) + geom_point(size=3.0)+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 40, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 40, face = "bold"),
        legend.title = element_text(size = 30, face = "bold"),
        legend.position = "bottom", 
        legend.text = element_text(size = 35, face = "plain"),
        axis.text=element_text(size=25, face="bold"))+
  xlab("Gene Size")+ ylab("Mean Concordance Index")+
  ggtitle("Optimal Gene Number")+ 
  labs(color="Method")+
  scale_color_manual(values = c("#21908CFF","#FDE725FF", "#440154FF"))


#Saving the finished graph in .svg format
ggsave(filename = "Data/Reproducible-results/Figures/individual_metrics_optimal_gene_size_read.svg",
       plot     = print(methods_optimal_gene_read_plot_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")


#Random sample of genes (10 random samples taken) for READ.
#We will take the average of these 10 samplings. We will select the same number
#of genes as the number of genes that give our miRNA metric the best performance
#(350 genes)
random_read1 <- sample(colnames(cox_df), size = 350)
random_read2 <- sample(colnames(cox_df), size = 350)
random_read3 <- sample(colnames(cox_df), size = 350)
random_read4 <- sample(colnames(cox_df), size = 350)
random_read5 <- sample(colnames(cox_df), size = 350)
random_read6 <- sample(colnames(cox_df), size = 350)
random_read7 <- sample(colnames(cox_df), size = 350)
random_read8 <- sample(colnames(cox_df), size = 350)
random_read9 <- sample(colnames(cox_df), size = 350)
random_read10 <- sample(colnames(cox_df), size = 350)

#Saving the random results for reproducibility
write.csv(random_read1, "Data/Reproducible-results/Rmarkdown/random_read_genes1.csv")
write.csv(random_read2, "Data/Reproducible-results/Rmarkdown/random_read_genes2.csv")
write.csv(random_read3, "Data/Reproducible-results/Rmarkdown/random_read_genes3.csv")
write.csv(random_read4, "Data/Reproducible-results/Rmarkdown/random_read_genes4.csv")
write.csv(random_read5, "Data/Reproducible-results/Rmarkdown/random_read_genes5.csv")
write.csv(random_read6, "Data/Reproducible-results/Rmarkdown/random_read_genes6.csv")
write.csv(random_read7, "Data/Reproducible-results/Rmarkdown/random_read_genes7.csv")
write.csv(random_read8, "Data/Reproducible-results/Rmarkdown/random_read_genes8.csv")
write.csv(random_read9, "Data/Reproducible-results/Rmarkdown/random_read_genes9.csv")
write.csv(random_read10, "Data/Reproducible-results/Rmarkdown/random_read_genes10.csv")

#Putting all the gene vectors together in a list to loop over for cox model
random_read_gene_list <- list(random_read1, random_read2, random_read3,
                              random_read4, random_read5, random_read6,
                              random_read7, random_read8, random_read9,
                              random_read10)


all_random_gene_cindices <- seq(1,10, 1)

for(rg in all_random_gene_cindices){
  current_genes <- random_read_gene_list[[rg]]
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = current_genes,
                                cox.df = cox_df,
                                gene.num = 350,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/random_read_coefs_for_random_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the all_random_gene_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  all_random_gene_cindices[rg] <- top_cindex
  
}

write.csv(all_random_gene_cindices,
          "Data/Reproducible-results/Rmarkdown/read_random_genes.csv")

mean_random <- mean(all_random_gene_cindices)


write.csv(read_methods_comp_df, "Data/Reproducible-results/Rmarkdown/read_method_comparison_df.csv")



#MAD + SDE metric for READ
#We first do alpha weight optimization and then fit the elastic-net penalized
#cox model to every combination of alpha and assess its performance through 
#10-fold cross-validation

#Weight optimization
mad_sde_read_optimized <- two_weight_optimizer(first.metric = mad.genes,
                                               second.metric = sde.genes,
                                               my.filename = "Data/Reproducible-results/Rmarkdown/mad_sde_read_optimized.rds")

```

```{r}
#Penalized cox model----
c_index <- rep(0, 59)
gene_sizes <- seq(100, 3000, 50)

for(gs in gene_sizes){
  for(ms in mad_sde_read_optimized[1:11]){
    cox_model <- cox_model_fitter(my.seed = 1,
                                  cox.predictors = ms,
                                  cox.df = cox_df,
                                  gene.num = gs,
                                  tumor.stage = FALSE,
                                  tumor.n = FALSE,
                                  tumor.m = FALSE,
                                  my.filename = paste0("Data/Reproducible-results/Rmarkdown/mad_sde_read_coefs_",gs,"_genes_",ms,"_index.csv"))
    
    #Getting the top concordance index from the cross validation and then rounding
    #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
    #the c_index list with the result
    top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
    c_index[which(gene_sizes==gs)] <- top_cindex
    
  }
  
  
}

mad_sde_finished_df <- as.data.frame(cbind(gene_sizes, c_index))

write.csv(mad_sde_finished_df, "Data/Reproducible-results/Rmarkdown/mad_sde_read_df.csv")
  
#Now constructing a data frame of all the methods
read_methods_comp_df <- data.frame(Method=c("MAD", "SDE", 
                                            "miRNA", "MAD + SDE" ,
                                            "Random Genes"),
                                   c_index=c(0.6932, 0.7224, 
                                             0.7425,0.6932, mean_random))

#Factoring the levels to make the plot nicer
read_methods_comp_df$Method <- factor(read_methods_comp_df$Method,
                                      levels = c("miRNA", "MAD", "SDE",
                                                 "MAD + SDE",
                                                 "Random Genes"))

#Plotting the comparison of methods for READ
individual_graph_read <-ggplot(data = read_methods_comp_df,
                               aes(x=Method, y=c_index, fill=Method))+
  geom_bar(stat = "identity")+
  labs(title = "TCGA-READ",
       x = "Method",
       y = "Concordance Index",
       fill = "Concordance Index")+
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 40,
                                  family = "sans"),
        panel.background = element_blank(),
        axis.line = element_line(colour = "grey", size = 2.5, lineend = "round"),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 34, family = "sans", angle = 45, vjust = 0.50),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "none")

individual_graph_read + coord_cartesian(ylim = c(0.5,0.75))+ 
  scale_fill_manual(values = c("#FDE725FF","#404788FF", "#404788FF",
                               "#404788FF", "#404788FF")) 

individual_graph_read <- individual_graph_read + coord_cartesian(ylim = c(0.5,0.75))+ 
  scale_fill_manual(values = c("#FDE725FF","#404788FF", "#404788FF",
                               "#404788FF", "#404788FF")) 

#Saving the result
ggsave(filename = "Data/Reproducible-results/Rmarkdown/methods_comparison_read.svg",
       plot     = print(individual_graph_read, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")




#MAD + SDE metric for COAD
#We first do alpha weight optimization and then fit the elastic-net penalized
#cox model to every combination of alpha and assess its performance through 
#10-fold cross-validation

#Weight optimization
mad_sde_coad_optimized <- two_weight_optimizer(first.metric = mad.genes,
                                               second.metric = sde.genes,
                                               my.filename = "Data/Reproducible-results/Rmarkdown/mad_sde_coad_optimized.rds")

```

```{r}
#Penalized cox model----
c_index <- rep(0, 59)
gene_sizes <- seq(100, 3000, 50)

for(gs in gene_sizes){
  for(ms in mad_sde_coad_optimized[1:11]){
    cox_model <- cox_model_fitter(my.seed = 1,
                                  cox.predictors = ms,
                                  cox.df = cox_df,
                                  gene.num = gs,
                                  tumor.stage = FALSE,
                                  tumor.n = FALSE,
                                  tumor.m = FALSE,
                                  my.filename = paste0("Data/Reproducible-results/Rmarkdown/mad_sde_coad_coefs_",gs,"_genes_",ms,"_index.csv"))
    
    #Getting the top concordance index from the cross validation and then rounding
    #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
    #the c_index list with the result
    top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
    c_index[which(gene_sizes==gs)] <- top_cindex
    
  }
  
  
}

mad_sde_finished_df <- as.data.frame(cbind(gene_sizes, c_index))

write.csv(mad_sde_finished_df, "Data/Reproducible-results/Rmarkdown/mad_sde_coad_df.csv")

#Random sample of genes (10 random samples taken) for COAD.
#We will take the average of these 10 samplings. We will select the same number
#of genes as the number of genes that give our miRNA metric the best performance
#(1,900 genes)
random_coad1 <- sample(colnames(cox_df), size = 1900)
random_coad2 <- sample(colnames(cox_df), size = 1900)
random_coad3 <- sample(colnames(cox_df), size = 1900)
random_coad4 <- sample(colnames(cox_df), size = 1900)
random_coad5 <- sample(colnames(cox_df), size = 1900)
random_coad6 <- sample(colnames(cox_df), size = 1900)
random_coad7 <- sample(colnames(cox_df), size = 1900)
random_coad8 <- sample(colnames(cox_df), size = 1900)
random_coad9 <- sample(colnames(cox_df), size = 1900)
random_coad10 <- sample(colnames(cox_df), size = 1900)

#Saving the random results for reproducibility
write.csv(random_coad1, "Data/Reproducible-results/Rmarkdown/random_coad_genes1.csv")
write.csv(random_coad2, "Data/Reproducible-results/Rmarkdown/random_coad_genes2.csv")
write.csv(random_coad3, "Data/Reproducible-results/Rmarkdown/random_coad_genes3.csv")
write.csv(random_coad4, "Data/Reproducible-results/Rmarkdown/random_coad_genes4.csv")
write.csv(random_coad5, "Data/Reproducible-results/Rmarkdown/random_coad_genes5.csv")
write.csv(random_coad6, "Data/Reproducible-results/Rmarkdown/random_coad_genes6.csv")
write.csv(random_coad7, "Data/Reproducible-results/Rmarkdown/random_coad_genes7.csv")
write.csv(random_coad8, "Data/Reproducible-results/Rmarkdown/random_coad_genes8.csv")
write.csv(random_coad9, "Data/Reproducible-results/Rmarkdown/random_coad_genes9.csv")
write.csv(random_coad10, "Data/Reproducible-results/Rmarkdown/random_coad_genes10.csv")

#Putting all the gene vectors together in a list to loop over for cox model
random_coad_gene_list <- list(random_coad1, random_coad2, random_coad3,
                              random_coad4, random_coad5, random_coad6,
                              random_coad7, random_coad8, random_coad9,
                              random_coad10)

all_random_gene_cindices <- seq(1,10, 1)

for(rg in all_random_gene_cindices){
  current_genes <- random_coad_gene_list[[rg]]
  cox_model <- cox_model_fitter(my.seed = 1,
                                cox.predictors = current_genes,
                                cox.df = cox_df,
                                gene.num = 1900,
                                tumor.stage = FALSE,
                                tumor.n = FALSE,
                                tumor.m = FALSE,
                                my.filename = paste0("Data/Reproducible-results/Rmarkdown/random_coad_coefs_for_random_genes.csv"))
  
  #Getting the top concordance index from the cross validation and then rounding
  #it to 4 digits to follow cv.glmnet reporting convention. Finally, we update
  #the all_random_gene_cindices list with the result
  top_cindex <- round(cox_model$CV$cvm[cox_model$CV$index[1]], digits = 4)
  all_random_gene_cindices[rg] <- top_cindex
  
}

write.csv(all_random_gene_cindices,
          "Data/Reproducible-results/Rmarkdown/coad_random_genes.csv")

mean_random <- mean(all_random_gene_cindices)


#Now constructing a data frame of all the methods
coad_methods_comp_df <- data.frame(Method=c("MAD", "SDE", 
                                            "miRNA", "MAD + SDE" ,
                                            "Random Genes"),
                                   c_index=c(0.6395, 0.6721, 
                                             0.7076,0.6395, mean_random))

#Factoring the levels to make the plot nicer
coad_methods_comp_df$Method <- factor(coad_methods_comp_df$Method,
                                      levels = c("miRNA", "MAD", "SDE",
                                                 "MAD + SDE",
                                                 "Random Genes"))




write.csv(coad_methods_comp_df, "Data/Reproducible-results/Rmarkdown/coad_method_comparison_df.csv")


#Plotting the comparison of methods for COAD
individual_graph_coad <-ggplot(data = coad_methods_comp_df,
                               aes(x=Method, y=c_index, fill=Method))+
  geom_bar(stat = "identity")+
  labs(title = "TCGA-COAD",
       x = "Method",
       y = "Concordance Index",
       fill = "Concordance Index")+
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 40,
                                  family = "sans"),
        panel.background = element_blank(),
        axis.line = element_line(colour = "grey", size = 2.5, lineend = "round"),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 34, family = "sans", angle = 45, vjust = 0.50),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "none")

individual_graph_coad + coord_cartesian(ylim = c(0.5,0.72))+ 
  scale_fill_manual(values = c("#FDE725FF","#404788FF", "#404788FF",
                               "#404788FF", "#404788FF")) 

individual_graph_coad <- individual_graph_coad + coord_cartesian(ylim = c(0.5,0.72))+
  scale_fill_manual(values = c("#FDE725FF","#404788FF", "#404788FF",
                               "#404788FF", "#404788FF"))

#Saving the result
ggsave(filename = "Data/Reproducible-results/Rmarkdown/methods_comparison_coad.svg",
       plot     = print(individual_graph_coad, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")
```

## Step Seventeen: Doing grid search and plotting for all methods
```{r}
#CC Singlecell MS grid search COAD
#See server_speedup_coad.R for the code


#CC Singlecell MS grid search READ
#See server_speedup_read.R for the code


#Reading in the results files of the CC Singlecell MS COAD grid search
coad_ms_0 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0_cc_singlecell_ms_coad_used_combo_100_1010_index_5_df.csv")
colnames(coad_ms_0) <- c("number", "c_index")
coad_ms_0$mirna_num <- rep(seq(100,800,100), each = 11)
coad_ms_0$mirna_target <- rep(seq(10, 1010, by=100), times = 8)

coad_ms_05 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.5_cc_singlecell_ms_coad_used_combo_100_1010_index_5_df.csv")
colnames(coad_ms_05) <- c("number", "c_index")
coad_ms_05 <- coad_ms_05[89:176,]
coad_ms_05$mirna_num <- rep(seq(100,800,100), each = 11)
coad_ms_05$mirna_target <- rep(seq(10, 1010, by=100), times = 8)

coad_ms_1 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_1_cc_singlecell_ms_coad_used_combo_100_1010_index_5_df.csv")
colnames(coad_ms_1) <- c("number", "c_index")
coad_ms_1 <- coad_ms_1[177:264,]
coad_ms_1$mirna_num <- rep(seq(100,800,100),each = 11)
coad_ms_1$mirna_target <- rep(seq(10, 1010, by=100), times = 8)





#Plotting the results of the CC Singlecell MS COAD grid search
#Alpha 0
heatmap_coad_ccs_ms_0 <- ggplot(data = coad_ms_0, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 0",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_0 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_0.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#Alpha 0.5
heatmap_coad_ccs_ms_05 <- ggplot(data = coad_ms_05, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 0.5",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_05 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_05.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#Alpha 1
heatmap_coad_ccs_ms_1 <- ggplot(data = coad_ms_1, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_1.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")



#Reading in the results files of the CC Singlecell MS READ grid search
read_ms_0 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_0_cc_singlecell_ms_read_used_combo_100_1010_index_8_df copy.csv")
colnames(read_ms_0) <- c("number", "c_index")
read_ms_0$mirna_num <- rep(seq(100,1000,100), 11)
read_ms_0$mirna_target <- rep(seq(10, 1010, by=100), 10)


read_ms_05 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_0.5_cc_singlecell_ms_read_used_combo_100_1010_index_8_df.csv")
colnames(read_ms_05) <- c("number", "c_index")
read_ms_05 <- read_ms_05[111:220,]
read_ms_05$mirna_num <- rep(seq(100,1000,100), 11)
read_ms_05$mirna_target <- rep(seq(10, 1010, by=100), 10)

read_ms_1 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_1_cc_singlecell_ms_read_used_combo_100_1010_index_11_df.csv")
colnames(read_ms_1) <- c("number", "c_index")
read_ms_1 <- read_ms_1[221:330,]
read_ms_1$mirna_num <- rep(seq(100,1000,100), 11)
read_ms_1$mirna_target <- rep(seq(10, 1010, by=100), 10)



#Plotting the results of the CC Singlecell MS READ grid search
#READ MS Alpha 0
heatmap_read_ccs_ms_0 <- ggplot(data = read_ms_0, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS READ Alpha = 0",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ms_0_ccs_ms_finished <- heatmap_read_ccs_ms_0 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_read_grid_search_heatmap_alpha_0.svg",
       plot     = print(heatmap_read_ms_0_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#READ MS Alpha 0.5
heatmap_read_ccs_ms_05 <- ggplot(data = read_ms_05, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS READ Alpha = 0.5",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ms_05_ccs_ms_finished <- heatmap_read_ccs_ms_05 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_read_grid_search_heatmap_alpha_05.svg",
       plot     = print(heatmap_read_ms_05_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")



#READ MS Alpha 1
heatmap_read_ccs_ms_1 <- ggplot(data = read_ms_1, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS READ Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ms_1_ccs_ms_finished <- heatmap_read_ccs_ms_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_read_grid_search_heatmap_alpha_1.svg",
       plot     = print(heatmap_read_ms_1_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#CC Singlecell MM COAD
coad_mm_0 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0_cc_singlecell_mm_coad_used_combo_100_1010_index_5_df.csv")
colnames(coad_mm_0) <- c("number", "c_index")
coad_mm_0$mirna_num <- rep(seq(100,800,100), 11)
coad_mm_0$mirna_target <- rep(seq(10, 1010, by=100), 8)

coad_mm_05 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.5_cc_singlecell_mm_coad_used_combo_100_1010_index_10_df.csv")
colnames(coad_mm_05) <- c("number", "c_index")
coad_mm_05$mirna_num <- rep(seq(100,800,100), 11)
coad_mm_05$mirna_target <- rep(seq(10, 1010, by=100), 8)


coad_mm_1 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_1_cc_singlecell_mm_coad_used_combo_100_1010_index_10_df.csv")
colnames(coad_mm_1) <- c("number", "c_index")
coad_mm_1$mirna_num <- rep(seq(100,800,100), 11)
coad_mm_1$mirna_target <- rep(seq(10, 1010, by=100), 8)



#Alpha 0
heatmap_coad_ccs_mm_0 <- ggplot(data = coad_mm_0, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MM COAD Alpha = 0",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_mm_finished <- heatmap_coad_ccs_mm_0 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mm_coad_grid_search_heatmap_alpha_0.svg",
       plot     = print(heatmap_coad_ccs_mm_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#Alpha 0.5
heatmap_coad_ccs_mm_05 <- ggplot(data = coad_mm_05, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MM COAD Alpha = 0.5",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans", margin=margin(0,20,0,0)),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_mm_finished <- heatmap_coad_ccs_mm_05 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mm_coad_grid_search_heatmap_alpha_05.svg",
       plot     = print(heatmap_coad_ccs_mm_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")




#Alpha 1
heatmap_coad_ccs_mm_1 <- ggplot(data = coad_mm_1, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MM COAD Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans", margin=margin(0,20,0,0)),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_mm_finished <- heatmap_coad_ccs_mm_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mm_coad_grid_search_heatmap_alpha_1.svg",
       plot     = print(heatmap_coad_ccs_mm_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")


#CC Singlecell MM READ
read_mm_0 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_0_cc_singlecell_mm_read_used_combo_100_1010_index_1_df.csv")
colnames(read_mm_0) <- c("number", "c_index")
read_mm_0$mirna_num <- rep(seq(100,1000,100), 11)
read_mm_0$mirna_target <- rep(seq(10, 1010, by=100), 10)

read_mm_05 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_0.5_cc_singlecell_mm_read_used_combo_100_1010_index_7_df.csv")
colnames(read_mm_05) <- c("number", "c_index")
read_mm_05$mirna_num <- rep(seq(100,1000,100), 11)
read_mm_05$mirna_target <- rep(seq(10, 1010, by=100), 10)


read_mm_1 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_1_cc_singlecell_mm_read_used_combo_100_1010_index_10_df.csv")
colnames(read_mm_1) <- c("number", "c_index")
read_mm_1$mirna_num <- rep(seq(100,1000,100), 11)
read_mm_1$mirna_target <- rep(seq(10, 1010, by=100), 10)



#Alpha 0
heatmap_read_ccs_mm_0 <- ggplot(data = read_mm_0, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MM READ Alpha = 0",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans", margin = margin(0,20,0,0)),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ccs_mm_finished <- heatmap_read_ccs_mm_0 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mm_read_grid_search_heatmap_alpha_0.svg",
       plot     = print(heatmap_read_ccs_mm_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#Alpha 0.5
heatmap_read_ccs_mm_05 <- ggplot(data = read_mm_05, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MM READ Alpha = 0.5",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ccs_mm_finished <- heatmap_read_ccs_mm_05 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mm_read_grid_search_heatmap_alpha_05.svg",
       plot     = print(heatmap_read_ccs_mm_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#Alpha 1
heatmap_read_ccs_mm_1 <- ggplot(data = read_mm_1, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MM READ Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ccs_mm_finished <- heatmap_read_ccs_mm_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mm_read_grid_search_heatmap_alpha_1.svg",
       plot     = print(heatmap_read_ccs_mm_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#CC Singlecell MMS COAD
coad_mms_0 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0_cc_singlecell_mms_coad_used_combo_100_1010_index_86_df.csv")
colnames(coad_mms_0) <- c("number", "c_index")
coad_mms_0$mirna_num <- rep(seq(100,800,100), each=11)
coad_mms_0$mirna_target <- rep(seq(10, 1010, by=100),times =8)

coad_mms_05 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.5_cc_singlecell_mms_coad_used_combo_100_1010_index_17_df.csv")
colnames(coad_mms_05) <- c("number", "c_index")
coad_mms_05$mirna_num <- rep(seq(100,800,100), each = 11)
coad_mms_05$mirna_target <- rep(seq(10, 1010, by=100), times = 8)


coad_mms_1 <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_1_cc_singlecell_mms_coad_used_combo_100_1010_index_17_df.csv")
colnames(coad_mms_1) <- c("number", "c_index")
coad_mms_1$mirna_num <- rep(seq(100,800,100), each = 11)
coad_mms_1$mirna_target <- rep(seq(10, 1010, by=100), times = 8)



#Alpha 0
heatmap_coad_ccs_mms_0 <- ggplot(data = coad_mms_0, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MMS COAD Alpha = 0",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_mms_finished <- heatmap_coad_ccs_mms_0 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mms_coad_grid_search_heatmap_alpha_0.svg",
       plot     = print(heatmap_coad_ccs_mms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#Alpha 0.5
heatmap_coad_ccs_mms_05 <- ggplot(data = coad_mms_05, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MMS COAD Alpha = 0.5",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans", margin=margin(0,20,0,0)),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_mms_finished <- heatmap_coad_ccs_mms_05 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mms_coad_grid_search_heatmap_alpha_05.svg",
       plot     = print(heatmap_coad_ccs_mms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")




#Alpha 1
heatmap_coad_ccs_mms_1 <- ggplot(data = coad_mms_1, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MMS COAD Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans", margin=margin(0,20,0,0)),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_mms_finished <- heatmap_coad_ccs_mms_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mms_coad_grid_search_heatmap_alpha_1.svg",
       plot     = print(heatmap_coad_ccs_mms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")


#CC Singlecell MMS READ
read_mms_0 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_0_cc_singlecell_mms_read_used_combo_900_1010_index_56_df.csv")
colnames(read_mms_0) <- c("number", "c_index")
read_mms_0$mirna_num <- rep(seq(100,1000,100), each=11)
read_mms_0$mirna_target <- rep(seq(10, 1010, by=100), times=10)

read_mms_05 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_0.5_cc_singlecell_mms_read_used_combo_100_1010_index_7_df.csv")
colnames(read_mms_05) <- c("number", "c_index")
read_mms_05$mirna_num <- rep(seq(100,1000,100), 11)
read_mms_05$mirna_target <- rep(seq(10, 1010, by=100), 10)


read_mms_1 <- read.csv("Data/Reproducible-results/Data/Outputs/READ/top_cindices_alpha_1_cc_singlecell_mms_read_used_combo_100_1010_index_10_df.csv")
colnames(read_mms_1) <- c("number", "c_index")
read_mms_1$mirna_num <- rep(seq(100,1000,100), 11)
read_mms_1$mirna_target <- rep(seq(10, 1010, by=100), 10)



#Alpha 0
heatmap_read_ccs_mms_0 <- ggplot(data = read_mms_0, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MMS READ Alpha = 0",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans", margin = margin(0,20,0,0)),
        legend.position = "bottom",
        legend.key.width = unit(2.5,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ccs_mms_finished <- heatmap_read_ccs_mms_0 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mms_read_grid_search_heatmap_alpha_0.svg",
       plot     = print(heatmap_read_ccs_mms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#Alpha 0.5
heatmap_read_ccs_mms_05 <- ggplot(data = read_mms_05, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MMS READ Alpha = 0.5",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ccs_mms_finished <- heatmap_read_ccs_mms_05 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mms_read_grid_search_heatmap_alpha_05.svg",
       plot     = print(heatmap_read_ccs_mms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#Alpha 1
heatmap_read_ccs_mms_1 <- ggplot(data = read_mms_1, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MMS READ Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_read_ccs_mms_finished <- heatmap_read_ccs_mms_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_mms_read_grid_search_heatmap_alpha_1.svg",
       plot     = print(heatmap_read_ccs_mms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")




#Additional alpha values for glmnet on COAD for CC Singlecell MS
alpha_06_df <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.6_cc_singlecell_ms_coad_df.csv")
alpha_07_df <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.7_cc_singlecell_ms_coad_df.csv")
alpha_08_df <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.8_cc_singlecell_ms_coad_df.csv")
alpha_09_df <- read.csv("Data/Reproducible-results/Data/Outputs/COAD/top_cindices_alpha_0.9_cc_singlecell_ms_coad_df.csv")


colnames(alpha_06_df) <- c("X", "mirna_num", "mirna_target", "c_index")
colnames(alpha_07_df) <- c("X", "mirna_num", "mirna_target", "c_index")
colnames(alpha_08_df) <- c("X", "mirna_num", "mirna_target", "c_index")
colnames(alpha_09_df) <- c("X", "mirna_num", "mirna_target", "c_index")

alpha_06_df$mirna_num <- rep(seq(100,800,100), each=11)
alpha_07_df$mirna_num <- rep(seq(100,800,100), each=11)
alpha_08_df$mirna_num <- rep(seq(100,800,100), each=11)
alpha_09_df$mirna_num <- rep(seq(100,800,100), each=11)

#Alpha 0.6
heatmap_coad_ccs_ms_06 <- ggplot(data = alpha_06_df, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 0.6",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_06 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_06.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#Alpha 0.7
heatmap_coad_ccs_ms_07 <- ggplot(data = alpha_07_df, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 0.7",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_07 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_07.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")


#Alpha 0.8
heatmap_coad_ccs_ms_08 <- ggplot(data = alpha_08_df, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 0.8",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_08 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_08.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

#Alpha 0.9
heatmap_coad_ccs_ms_09 <- ggplot(data = alpha_09_df, aes(x=mirna_num, y=mirna_target, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC Singlecell MS COAD Alpha = 0.9",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_finished <- heatmap_coad_ccs_ms_09 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "Data/Reproducible-results/Rmarkdown/cc_singlecell_ms_coad_grid_search_heatmap_alpha_09.svg",
       plot     = print(heatmap_coad_ccs_ms_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

```
## Step Eighteen: Doing a grid search of miRNA metric only. Here we are testing if we have fixed the weird behavior we have seen previously where all results were the same regardless of method used. We believe this was caused by including the 'fold id' argument to glmnet which is only meant to be used to compare alpha values. They state in their help for cv.glmnet: "The function runs glmnet nfolds+1 times; the first to get the lambda sequence, and then the remainder to compute the fit with each of the folds omitted. The error is accumulated, and the average error and standard deviation over the folds is computed. Note that cv.glmnet does NOT search for values for alpha. A specific value should be supplied, else alpha=1 is assumed by default. If users would like to cross-validate alpha as well, they should call cv.glmnet with a pre-computed vector foldid, and then use this same fold vector in separate calls to cv.glmnet with different values of alpha. Note also that the results of cv.glmnet are random, since the folds are selected at random. Users can reduce this randomness by running cv.glmnet many times, and averaging the error curves." We validated for our data that indeed alpha = 1 is the best performing value (i.e., lasso regularization is the best regularization to use compared to ridge and elastic-net regularizations). We now will compare our methods with alpha always set to 1 and no longer pass the foldid argument. 


```{r}
mirna_only_df <- read.csv("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Data/alpha_1_cindices_mirna_only_finished.csv")
colnames(mirna_only_df) <- c("mirna_num", "c_index")
mirna_only_df$mirna_num <- rep(seq(800,100,-100),each=11)
mirna_only_df$mirna_targets <- rep(seq(10,1010,100), times=8)
head(mirna_only_df, n=22)
```
## Now plotting the heatmap
```{r}
heatmap_coad_mirna_1 <- ggplot(data = mirna_only_df, aes(x=mirna_num, y=mirna_targets, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "miRNA COAD Alpha = 1",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_mirna_finished <- heatmap_coad_mirna_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/heatmap_coad_mirna_alpha_1.svg",
       plot     = print(heatmap_mirna_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 32, height = 32,
       units    = "cm")

heatmap_mirna_finished
```
Now looking at the CC Singlecell MS at a non-ideal gene point for the MS method (just using the ideal point of miRNA)
```{r}
ccs_ms_df <- read.csv("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Data/top_cindices_alpha_1_cc_singlecell_ms_coad_df_finished_no_foldid_finished_all_combos.csv")
colnames(ccs_ms_df) <- c("X","mirna_num", "mirna_targets", "c_index")
head(ccs_ms_df, n=22)
```

## Now plotting the heatmap
```{r}
heatmap_coad_ccs_ms_1 <- ggplot(data = ccs_ms_df, aes(x=mirna_num, y=mirna_targets, fill=c_index))+
  geom_tile()+
  scale_fill_gradient(low = "white", high = "red")+
  geom_text(aes(label = round(c_index, 4)), color = "white")+ 
  coord_fixed()+
  labs(x ="# of miRNAs",
       y = "# of miRNA Targets",
       title = "CC  Singlecell MS COAD Alpha = 1 Non-Optimal",
       fill = "Concordance Index")+
  theme(panel.background = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold", size = 40),
        axis.title.x = element_text(size = 40, family = "sans", face = "bold"),
        axis.title.y = element_text(size = 40, family = "sans", face = "bold"),
        axis.text.x = element_text(size = 30, family = "sans"),
        axis.text.y = element_text(size = 40, family = "sans"),
        legend.text = element_text(size = 25, family = "sans"),
        legend.title = element_text(size = 40, family = "sans"),
        legend.position = "bottom",
        legend.key.width = unit(2.0,"cm"))

#Changing to color-blind friendly palette
heatmap_coad_ccs_ms_1 <- heatmap_coad_ccs_ms_1 + scale_fill_viridis_c()

#Now saving the heat map
ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/heatmap_coad_cc_singlecell_ms_non_opt_alpha_1_version2.svg",
       plot     = print(heatmap_coad_ccs_ms_1, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 37, height = 37,
       units    = "cm")

heatmap_coad_ccs_ms_1
```



#Step 19: We found the ideal point for CC Singlecell MS on TCGA-READ  (Gene size = 600 with c-index = 0.8283). Just showing the line graph for the 11 combinations of our linear model for brevity and concision Color pallete: "#21908CFF","#FDE725FF", "#440154FF"

```{r}
cc_singlecell_ms_ideal <- read.csv("~/Desktop/cc_singlecell_ms_optimal_gene_df_read.csv")
invisible(which.max(cc_singlecell_ms_ideal$c_index))
cc_singlecell_sub <- cc_singlecell_ms_ideal[4131:4189,]

#Plot of the ideal gene size
cc_singlecell_ms_optimal_gene_read_plot <- ggplot(data = cc_singlecell_sub,
                                         aes(x=gene_size, y=c_index))

#Making the plot much nicer
cc_singlecell_ms_optimal_gene_read_plot_finished <-cc_singlecell_ms_optimal_gene_read_plot +
  geom_line(size=2.5, color="#FDE725FF") + geom_point(size=3.0, color="#FDE725FF")+
  theme(panel.background = element_blank(),
        plot.title = element_text(size = 40, face = "bold", hjust = 0.5),
        axis.title = element_text(size = 40, face = "bold"),
        legend.title = element_text(size = 30, face = "bold"),
        legend.position = "bottom", 
        legend.text = element_text(size = 35, face = "plain"),
        axis.text=element_text(size=25, face="bold"))+
  xlab("Gene Size")+ ylab("Mean Concordance Index")+
  ylim(0.5,0.85)+
  ggtitle("CC Singlecell MS Optimal Gene Number \n TCGA-READ") 


#Saving the finished graph in .svg format
setwd("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs")
ggsave(filename = "cc_singlecell_ms_optimal_gene_size_read.svg",
       plot     = print(cc_singlecell_ms_optimal_gene_read_plot_finished, newpage = FALSE),
       device   = "svg", dpi=300,
       width    = 34, height = 34,
       units    = "cm")

```

#Step 20: scDD concordance index performance on READ
```{r}
#scDD method----
#Loading our single cell data for scDD
setwd("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell")
all_tumor_cells_fpkm <- read.csv("Data/Single-cell-data/FPKM/GSE81861_CRC_tumor_all_cells_FPKM.csv")
rownames(all_tumor_cells_fpkm) <- all_tumor_cells_fpkm$X
all_tumor_cells_fpkm <- gene_name_cleaner(data.to.clean = all_tumor_cells_fpkm)
all_tumor_cells_fpkm <- t(all_tumor_cells_fpkm)
all_tumor_cells_fpkm <- subset(all_tumor_cells_fpkm, select=c(RHC3546__Tcell__.C6E879:RHC6041__Macrophage__.FFFF55))

keep_rows <- rowSums(all_tumor_cells_fpkm > 0) > 10
all_tumor_cells_fpkm <- all_tumor_cells_fpkm[keep_rows,]
all_tumor_cells_fpkm <- apply(all_tumor_cells_fpkm, c(1,2), as.numeric)


#Looking at the distribution of library sizes
library_size_plot_1 <- ggplot() +
  geom_histogram(aes(x=colSums(all_tumor_cells_fpkm)), bins=100) +
  geom_vline(xintercept = 1000, color='red') +
  theme(panel.background = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))+
  xlab("Library Size Distribution")+
  ylab("Count") + ggtitle("Single-cell Library Size for scDD Tumor")+
  scale_y_continuous(limits=c(0, 35), expand = c(0, 0))

library_size_plot_1


ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/single_cell_library_histogram_pre_process_step_1_scdd_tumor.svg",
       device = "svg", units = "cm", dpi = 300, width = 24, height = 24,
       plot = library_size_plot_1)



#Normalizing the library size
all_tumor_cells_fpkm <- library.size.normalize(t(all_tumor_cells_fpkm), verbose = TRUE)
all_tumor_cells_fpkm <- t(all_tumor_cells_fpkm)
tumor_col_names <- colnames(all_tumor_cells_fpkm)
tumor_row_names <- rownames(all_tumor_cells_fpkm)
head(as.data.frame(all_tumor_cells_fpkm))
all_tumor_cells_fpkm <- sqrt(all_tumor_cells_fpkm)
head(as.data.frame(all_tumor_cells_fpkm))


library_size_plot_2 <- ggplot() +
  geom_histogram(aes(x=colSums(all_tumor_cells_fpkm)), bins=100) +
  geom_vline(xintercept = 1000, color='red') +
  theme(panel.background = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))+
  xlab("Library Size Distribution")+
  ylab("Count") + ggtitle("Single-cell Library Size Normalized for scDD Tumor")+
  scale_y_continuous(limits=c(0, 35), expand = c(0, 0))

library_size_plot_2

ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/single_cell_library_histogram_pre_process_step_2_scdd_tumor.svg",
       device = "svg", units = "cm", dpi = 300, width = 20, height = 20,
       plot = library_size_plot_2)



#Denoising the single-cell data and saving the output
all_tumor_cells_fpkm <- magic_denoiser(sc.data = all_tumor_cells_fpkm,
                                magic.seed = 123, magic.solver = 'approximate')

saveRDS(all_tumor_cells_fpkm$denoised_sc_dataframe,
        file = "Data/Reproducible-results/Rmarkdown/denoised-colon-and-rectal-single-cell-data_scdd_tumor.rds")
```


```{r}
setwd("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell")
all_nm_cells_fpkm <- read.csv("Data/Single-cell-data/FPKM/GSE81861_CRC_NM_all_cells_FPKM.csv")
rownames(all_nm_cells_fpkm) <- all_nm_cells_fpkm$X
all_nm_cells_fpkm <- gene_name_cleaner(data.to.clean = all_nm_cells_fpkm)
all_nm_cells_fpkm <- t(all_nm_cells_fpkm)
all_nm_cells_fpkm <- subset(all_nm_cells_fpkm, select=c(RHC3934__Bcell__.7DEA7B:RHC6187__Macrophage__.FFFF55))

keep_rows <- rowSums(all_nm_cells_fpkm > 0) > 10
all_nm_cells_fpkm <- all_nm_cells_fpkm[keep_rows,]
all_nm_cells_fpkm <- apply(all_nm_cells_fpkm, c(1,2), as.numeric)


#Looking at the distribution of library sizes
library_size_plot_1 <- ggplot() +
  geom_histogram(aes(x=colSums(all_nm_cells_fpkm)), bins=100) +
  geom_vline(xintercept = 1000, color='red') +
  theme(panel.background = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))+
  xlab("Library Size Distribution")+
  ylab("Count") + ggtitle("Single-cell Library Size for scDD Normal")+
  scale_y_continuous(limits=c(0, 60), expand = c(0, 0))

library_size_plot_1


ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/single_cell_library_histogram_pre_process_step_1_scdd_nm.svg",
       device = "svg", units = "cm", dpi = 300, width = 24, height = 24,
       plot = library_size_plot_1)



#Normalizing the library size
all_nm_cells_fpkm <- library.size.normalize(t(all_nm_cells_fpkm), verbose = TRUE)
all_nm_cells_fpkm <- t(all_nm_cells_fpkm)
tumor_col_names <- colnames(all_nm_cells_fpkm)
tumor_row_names <- rownames(all_nm_cells_fpkm)
head(as.data.frame(all_nm_cells_fpkm))
all_nm_cells_fpkm <- sqrt(all_nm_cells_fpkm)
head(as.data.frame(all_nm_cells_fpkm))


library_size_plot_2 <- ggplot() +
  geom_histogram(aes(x=colSums(all_nm_cells_fpkm)), bins=100) +
  geom_vline(xintercept = 1000, color='red') +
  theme(panel.background = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))+
  xlab("Library Size Distribution")+
  ylab("Count") + ggtitle("Single-cell Library Size Normalized for scDD")+
  scale_y_continuous(limits=c(0, 35), expand = c(0, 0))

library_size_plot_2

ggsave(filename = "~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/Data/Reproducible-results/Rmarkdown/Outputs/single_cell_library_histogram_pre_process_step_2_scdd_nm.svg",
       device = "svg", units = "cm", dpi = 300, width = 20, height = 20,
       plot = library_size_plot_2)



#Denoising the single-cell data and saving the output
all_nm_cells_fpkm <- magic_denoiser(sc.data = all_nm_cells_fpkm,
                                       magic.seed = 123, magic.solver = 'approximate')

saveRDS(all_nm_cells_fpkm$denoised_sc_dataframe,
        file = "Data/Reproducible-results/Rmarkdown/denoised-colon-and-rectal-single-cell-data_scdd_nm.rds")

```

```{r}
#Doing pre-processing to get my data ready to go into the SingleCellExperiment data for scDD method
#container format
tumor_colnames <- paste("C1",seq(1:length(colnames(all_tumor_cells_fpkm$denoised_sc_dataframe))),sep = ".")
nm_colnames <- paste("C2",seq(1:length(colnames(all_nm_cells_fpkm$denoised_sc_dataframe))),sep = ".")
colnames(all_tumor_cells_fpkm$denoised_sc_dataframe) <- tumor_colnames
colnames(all_nm_cells_fpkm$denoised_sc_dataframe) <- nm_colnames

condition <- c(rep(1, ncol(all_tumor_cells_fpkm$denoised_sc_dataframe)),
               rep(2, ncol(all_nm_cells_fpkm$denoised_sc_dataframe)))

names(condition) <- c(colnames(all_tumor_cells_fpkm$denoised_sc_dataframe), colnames(all_nm_cells_fpkm$denoised_sc_dataframe))
i <- c(1:ncol(all_nm_cells_fpkm$denoised_sc_dataframe))  
z <- c(1:ncol(all_tumor_cells_fpkm$denoised_sc_dataframe))

all_nm_cells_fpkm <- apply(all_nm_cells_fpkm$denoised_sc_dataframe, c(1,2),           
                    function(x) as.numeric(as.character(x)))

all_tumor_cells_fpkm <- apply(all_tumor_cells_fpkm$denoised_sc_dataframe, c(1,2),            
                                 function(x) as.numeric(as.character(x)))

#Making the SingleCellExperiment object of my data---- 
unique_tumor_names <- unique(rownames(all_tumor_cells_fpkm))
all_tumor_cells_fpkm <- all_tumor_cells_fpkm[unique_tumor_names,]

unique_nm_names <- unique(rownames(all_nm_cells_fpkm))
all_nm_cells_fpkm <- all_nm_cells_fpkm[unique_nm_names,]

condition <- c(rep(1, ncol(all_tumor_cells_fpkm)), rep(2, ncol(all_nm_cells_fpkm)))


sce <- SingleCellExperiment(assays=list(normcounts=cbind(all_tumor_cells_fpkm,
                                                         all_nm_cells_fpkm)),
                            colData=data.frame(condition))

#Filtering the sce object
sce_filtered <- preprocess(sce, zero.thresh=0.9)

#For multiple cores----
BiocParallel::register(BiocParallel::MulticoreParam())

#scDD function and results----
prior_param=list(alpha=0.01, mu0=0, s0=0.01, a0=0.01, b0=0.01)
sce_significance_test<- scDD(sce_filtered, prior_param=prior_param, testZeroes=FALSE, categorize = FALSE)
scdd_res <- results(sce_significance_test)
scdd_res <- scdd_res[with(scdd_res, order(nonzero.pvalue.adj)), ]
scdd_res <- filter(scdd_res, nonzero.pvalue.adj<0.05)

readRDS(scdd_res,file = "Data/Reproducible-results/Rmarkdown/Outputs/scdd_res.rds")
write.csv(scdd_res, file = "Data/Reproducible-results/Rmarkdown/Outputs/scdd_res.csv")

```

```{r}
#For finding the optimal number of genes----
setwd("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell")
scdd_gene_nums <- seq(1, 570, 50)

for(num in scdd_gene_nums){
  scdd_sub <- scdd_res[1:num,]
  scdd_sub_finished<- data.frame(gene=scdd_sub$gene, pvalue=scdd_sub$nonzero.pvalue, pvalue.adj=scdd_sub$nonzero.pvalue.adj)
  write.csv(scdd_sub_finished, file = paste0("Data/Reproducible-results/Rmarkdown/scdd_top_",num,"_genes_cc_patients.csv"))
  
}
```


## Step 21: DESeq2 performance on READ
```{r}
setwd("~/Documents/PhD Program/Hong Lab/Projects/CC_Singlecell/")
#Reading in the count files
tumor_cells_ds2 <- read.csv(file = "Data/Single-cell-data/Counts/GSE81861_CRC_tumor_all_cells_COUNT.csv")
nm_cells_ds2 <- read.csv(file = "Data/Single-cell-data/Counts/GSE81861_CRC_NM_all_cells_COUNT.csv")
normal_num <- rep("normal", 266)
tumor_num <- rep("tumor", 375)
all_nums <- c(tumor_num, normal_num)
# nm_names <- rep(paste("NM",1:ncol(nm_cells_ds2)))
# tumor_names <- rep(paste("TM",1:ncol(tumor_cells_ds2)))
# all_names <- c(tumor_names, nm_names)

#Merging them together into one large dataframe
deseq2_df <- merge(tumor_cells_ds2, nm_cells_ds2)
rownames(deseq2_df) <- deseq2_df$X
deseq2_df <- subset(deseq2_df, select=c(RHC3546__Tcell__.C6E879:RHC6187__Macrophage__.FFFF55))
deseq2_rows <- rownames(deseq2_df)
deseq2_rows <- gene_vector_cleaner(unclean.data = deseq2_rows)
deseq2_cols <- colnames(deseq2_df)
deseq2_df <- deseq2_df[complete.cases(deseq2_df), ]
deseq2_df <- apply(deseq2_df, c(1,2), as.integer)
#rownames(deseq2_df) <- seq(1, nrow(deseq2_df), by=1)
#colnames(deseq2_df) <- seq(1, ncol(deseq2_df), by=1)
deseq2_mat <- as.matrix(deseq2_df)

#Making a summarizedExperiment object from the combined dataframe
deseq2_se <- SummarizedExperiment(assays=list(counts=deseq2_mat),
                                  colData=DataFrame(label=deseq2_cols),
                                  rowData=DataFrame(length=deseq2_rows),)



keep <-  rowSums(assay(deseq2_se)>5)>10
table(keep)

zinb_data <- deseq2_se[keep,]
zinb_data$cell_state <- all_nums


zinb_data <- zinb_data[names(zinb_data)[1:5000],]

#For multicore
BiocParallel::register(BiocParallel::MulticoreParam())

zinb_data <- zinbwave(zinb_data, K=0, BPPARAM = BiocParallel::bpparam(), 
                      epsilon=1e12, normalizedValues=FALSE,
                      observationalWeights = TRUE, verbose=TRUE)

dds <- DESeqDataSet(zinb_data, design=~cell_state)

dds <- estimateSizeFactors(dds, type="poscounts")

scr <- scran::calculateSumFactors(dds)
sizeFactors(dds) <- scr

dds <- DESeq(dds, sfType="poscounts", useT=TRUE, minmu=1e-6, minRep=Inf) 


dds_res <- DESeq2::results(dds)

resOrdered <- dds_res[order(dds_res$padj),]
save(resOrdered, file = "Data/Data-from-Cleaner-code/deseq2_top5000_genes_cc_patients.RData")

resOrdered_subset <- resOrdered[1:1800,]
save(resOrdered_subset, file = "Data/Data-from-Cleaner-code/deseq2_top1800_genes_cc_patients.RData")


cleaned_gene_names <- gene_vector_cleaner(unclean.data = rownames(resOrdered_subset))
resOrdered_subset_finished <- data.frame(gene=cleaned_gene_names, baseMean=resOrdered_subset$baseMean, log2FoldChange=resOrdered_subset$log2FoldChange, lfcSE=resOrdered_subset$lfcSE, stat=resOrdered_subset$stat, pvalue=resOrdered_subset$pvalue, padj=resOrdered_subset$padj)
write.csv(resOrdered_subset_finished, file = "Data/Data-from-Cleaner-code/deseq2_top_1800_genes_cc_patients.csv")

#Making a bunch of DESeq2 gene subsets for finding optimal point
deseq2_gene_nums <- seq(1, 3000, 50)

for(num in deseq2_gene_nums){
  deseq2_sub <- resOrdered[1:num,]
  cleaned_gene_names <- gene_vector_cleaner(unclean.data = rownames(deseq2_sub))
  deseq2_sub_finished<- data.frame(gene=cleaned_gene_names, baseMean=deseq2_sub$baseMean, log2FoldChange=deseq2_sub$log2FoldChange, lfcSE=deseq2_sub$lfcSE, stat=deseq2_sub$stat, pvalue=deseq2_sub$pvalue, padj=deseq2_sub$padj)
  write.csv(deseq2_sub_finished, file = paste0("deseq2_top_",num,"_genes_cc_patients.csv"))
  
}
```

